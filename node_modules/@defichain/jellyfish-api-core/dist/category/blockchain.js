"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = void 0;
/**
 * Blockchain RPCs for DeFi Blockchain
 */
class Blockchain {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get various state info regarding blockchain processing.
     *
     * @return {Promise<BlockchainInfo>}
     */
    getBlockchainInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockchaininfo', [], 'number');
        });
    }
    /**
     * Get a hash of block in best-block-chain at height provided.
     *
     * @param {number} height
     * @return {Promise<string>}
     */
    getBlockHash(height) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockhash', [height], 'number');
        });
    }
    /**
     * Get the height of the most-work fully-validated chain.
     *
     * @return {Promise<number>}
     */
    getBlockCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockcount', [], 'number');
        });
    }
    getBlock(hash, verbosity) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblock', [hash, verbosity], verbosity === 2
                ? {
                    tx: {
                        vout: {
                            value: 'bignumber'
                        }
                    }
                }
                : 'number');
        });
    }
    getBlockHeader(hash, verbosity) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockheader', [hash, verbosity], 'number');
        });
    }
    /**
     * Return information about all known tips in the block tree
     * including the main chain as well as orphaned branches.
     *
     * @return {Promise<ChainTip[]>}
     */
    getChainTips() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getchaintips', [], 'number');
        });
    }
    /**
     * Get the proof-of-work difficulty as a multiple of the minimum difficulty.
     *
     * @return {Promise<number>}
     */
    getDifficulty() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getdifficulty', [], 'number');
        });
    }
    /**
     * Get details of unspent transaction output (UTXO).
     *
     * @param {string} txId the transaction id
     * @param {number} index vout number
     * @param {boolean} includeMempool default true, whether to include mempool
     * @return {Promise<UTXODetails>}
     */
    getTxOut(txId, index, includeMempool = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('gettxout', [
                txId, index, includeMempool
            ], {
                value: 'bignumber'
            });
        });
    }
    /**
     * Get all transaction ids in memory pool as string[] if verbose is false
     * else as json object
     *
     * @param {boolean} verbose default = false, true for json object, false for array of transaction ids
     * @return {Promise<string[] | MempoolTx>}
     */
    getRawMempool(verbose) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getrawmempool', [verbose], 'bignumber');
        });
    }
    /**
     * Get block statistics for a given window.
     *
     * @param {number} hashOrHeight  The block hash or height of the target block.
     * @param {Array<keyof BlockStats>} stats Default = all values. See BlockStats Interface.
     * @return {Promise<BlockStats>}
     */
    getBlockStats(hashOrHeight, stats) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockstats', [hashOrHeight, stats], 'number');
        });
    }
    /**
     * Get the hash of the best (tip) block in the most-work fully-validated chain.
     *
     * @returns {Promise<string>}
     */
    getBestBlockHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getbestblockhash', [], 'number');
        });
    }
    /**
     * Returns details on the active state of the TX memory pool.
     *
     * @return {Promise<MempoolInfo>}
     */
    getMempoolInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmempoolinfo', [], { mempoolminfee: 'bignumber', minrelaytxfee: 'bignumber' });
        });
    }
    /**
     * Wait for any new block
     *
     * @param {number} [timeout=30000] in millis
     * @return Promise<WaitBlockResult> the current block on timeout or exit
     */
    waitForNewBlock(timeout = 30000) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('waitfornewblock', [timeout], 'number');
        });
    }
    /**
     * Waits for block height equal or higher than provided and returns the height and hash of the current tip.
     *
     *
     * @param {number} height
     * @param {number} [timeout=30000] in millis
     * @return Promise<WaitBlockResult> the current block on timeout or exit
     */
    waitForBlockHeight(height, timeout = 30000) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('waitforblockheight', [height, timeout], 'number');
        });
    }
    /**
     * Get statistics about the total number and rate of transactions in the chain.
     *
     * @param {number} [nBlocks] size of the window in number of blocks. Defaults to 1 month (~86,400) blocks.
     * @param {string} [blockHash] the hash of the block that ends the window. Defaults to the chain tip.
     * @return {Promise<ChainTxStats>}
     */
    getChainTxStats(nBlocks, blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getchaintxstats', [nBlocks, blockHash], 'number');
        });
    }
}
exports.Blockchain = Blockchain;
//# sourceMappingURL=blockchain.js.map