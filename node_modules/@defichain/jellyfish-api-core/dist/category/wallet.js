"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.InWalletTransactionCategory = exports.BIP125 = exports.WalletFlag = exports.ScriptType = exports.AddressType = exports.Mode = void 0;
var Mode;
(function (Mode) {
    Mode["UNSET"] = "UNSET";
    Mode["ECONOMICAL"] = "ECONOMICAL";
    Mode["CONSERVATIVE"] = "CONSERVATIVE";
})(Mode = exports.Mode || (exports.Mode = {}));
var AddressType;
(function (AddressType) {
    AddressType["LEGACY"] = "legacy";
    AddressType["P2SH_SEGWIT"] = "p2sh-segwit";
    AddressType["BECH32"] = "bech32";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
var ScriptType;
(function (ScriptType) {
    ScriptType["NONSTANDARD"] = "nonstandard";
    ScriptType["PUBKEY"] = "pubkey";
    ScriptType["PUBKEYHASH"] = "pubkeyhash";
    ScriptType["SCRIPTHASH"] = "scripthash";
    ScriptType["MULTISIG"] = "multisig";
    ScriptType["NULLDATA"] = "nulldata";
    ScriptType["WITNESS_V0_KEYHASH"] = "witness_v0_keyhash";
    ScriptType["WITNESS_UNKNOWN"] = "witness_unknown";
})(ScriptType = exports.ScriptType || (exports.ScriptType = {}));
var WalletFlag;
(function (WalletFlag) {
    WalletFlag["AVOID_REUSE"] = "avoid_reuse";
})(WalletFlag = exports.WalletFlag || (exports.WalletFlag = {}));
var BIP125;
(function (BIP125) {
    BIP125["YES"] = "yes";
    BIP125["NO"] = "no";
    BIP125["UNKNOWN"] = "unknown";
})(BIP125 = exports.BIP125 || (exports.BIP125 = {}));
var InWalletTransactionCategory;
(function (InWalletTransactionCategory) {
    InWalletTransactionCategory["SEND"] = "send";
    InWalletTransactionCategory["RECEIVE"] = "receive";
    InWalletTransactionCategory["GENERATE"] = "generate";
    InWalletTransactionCategory["IMMATURE"] = "immature";
    InWalletTransactionCategory["ORPHAN"] = "orphan";
})(InWalletTransactionCategory = exports.InWalletTransactionCategory || (exports.InWalletTransactionCategory = {}));
/**
 * Wallet RPCs for DeFi Blockchain
 */
class Wallet {
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the total available balance in wallet.
     *
     * @param {number} minimumConfirmation to include transactions confirmed at least this many times
     * @param {boolean} includeWatchOnly for watch-only wallets
     * @return Promise<BigNumber>
     */
    getBalance(minimumConfirmation = 0, includeWatchOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getbalance', ['*', minimumConfirmation, includeWatchOnly], 'bignumber');
        });
    }
    /**
     * Identical to getBalance to get untrusted pending balance
     *
     * @return Promise<BigNumber>
     */
    getUnconfirmedBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getunconfirmedbalance', [false], 'bignumber');
        });
    }
    /**
     * Returns an object with all balances.
     *
     * @return {Promise<WalletBalances>}
     */
    getBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getbalances', [false], 'bignumber');
        });
    }
    /**
     * Get list of UTXOs in wallet.
     *
     * @param {number} minimumConfirmation default = 1, to filter
     * @param {number} maximumConfirmation default = 9999999, to filter
     * @param {ListUnspentOptions} [options]
     * @param {string[]} [options.addresses] to filter
     * @param {boolean} [options.includeUnsafe=true] default = true, include outputs that are not safe to spend
     * @param {ListUnspentQueryOptions} [options.queryOptions]
     * @param {number} [options.queryOptions.minimumAmount] default = 0, minimum value of each UTXO
     * @param {number} [options.queryOptions.maximumAmount] default is 'unlimited', maximum value of each UTXO
     * @param {number} [options.queryOptions.maximumCount] default is 'unlimited', maximum number of UTXOs
     * @param {number} [options.queryOptions.minimumSumAmount] default is 'unlimited', minimum sum valie of all UTXOs
     * @param {string} [options.queryOptions.tokenId] default is 'all', filter by token
     * @return {Promise<UTXO[]>}
     */
    listUnspent(minimumConfirmation = 1, maximumConfirmation = 9999999, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { addresses = [], includeUnsafe = true, queryOptions = {} } = options;
            return yield this.client.call('listunspent', [
                minimumConfirmation, maximumConfirmation,
                addresses, includeUnsafe, queryOptions
            ], { amount: 'bignumber' });
        });
    }
    /**
     * Create a new wallet
     *
     * @param {string} walletName
     * @param {boolean} disablePrivateKeys
     * @param {CreateWalletOptions} [options]
     * @param {boolean} [options.blank]
     * @param {string} [options.passphrase]
     * @param {boolean} [options.avoidReuse]
     * @return {Promise<CreateWalletResult>}
     */
    createWallet(walletName, disablePrivateKeys = false, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { blank = false, passphrase = '', avoidReuse = false } = options;
            return yield this.client.call('createwallet', [walletName, disablePrivateKeys, blank, passphrase, avoidReuse], 'number');
        });
    }
    /**
     * Return object containing various wallet state info
     *
     * @return {Promise<WalletInfo>}
     */
    getWalletInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getwalletinfo', [], {
                balance: 'bignumber',
                unconfirmed_balance: 'bignumber',
                immature_balance: 'bignumber',
                paytxfee: 'bignumber'
            });
        });
    }
    /**
     * Change the state of the given wallet flag for a wallet
     *
     * @param {WalletFlag} flag to change. eg: avoid_reuse
     * @param {boolean} value optional, default = true
     * @return {Promise<WalletFlagResult>}
     */
    setWalletFlag(flag, value = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setwalletflag', [flag, value], 'number');
        });
    }
    /**
     * Returns a new DeFi address for receiving payments.
     * If 'label' is specified, it's added to the address book
     * so payments received with the address will be associated with 'label'
     *
     * @param {string} label for address to be linked to. It can also be set as empty string
     * @param {AddressType} addressType to use, eg: legacy, p2sh-segwit, bech32
     * @return {Promise<string>}
     */
    getNewAddress(label = '', addressType = AddressType.BECH32) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getnewaddress', [label, addressType], 'number');
        });
    }
    /**
     * Validate and return information about the given DFI address
     *
     * @param {string} address
     * @return {Promise<ValidateAddressResult>}
     */
    validateAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('validateaddress', [address], 'number');
        });
    }
    /**
     * Return information about the given address
     *
     * @param {string} address
     * @return {Promise<AddressInfo>}
     */
    getAddressInfo(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getaddressinfo', [address], 'number');
        });
    }
    /**
     * Send an amount to given address and return a transaction id
     *
     * @param {string} address
     * @param {number} amount
     * @param {SendToAddressOptions} [options]
     * @param {string} [options.comment]
     * @param {string} [options.commentTo]
     * @param {boolean} [options.subtractFeeFromAmount]
     * @param {boolean} [options.replaceable]
     * @param {number} [options.confTarget]
     * @param {Mode} [options.estimateMode]
     * @param {boolean} [options.avoidReuse]
     * @return {Promise<string>}
     */
    sendToAddress(address, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { comment = '', commentTo = '', subtractFeeFromAmount = false, replaceable = false, confTarget = 6, estimateMode = Mode.UNSET, avoidReuse = false } = options;
            return yield this.client.call('sendtoaddress', [
                address, amount, comment, commentTo, subtractFeeFromAmount,
                replaceable, confTarget, estimateMode, avoidReuse
            ], 'bignumber');
        });
    }
    /**
     * Lists groups of addresses which have had their common ownership made public
     * by common use as inputs or as the resulting change in past transactions
     *
     * @return {Promise<any[][][]>}
     */
    listAddressGroupings() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listaddressgroupings', [], 'bignumber');
        });
    }
    /**
     * Send given amounts to multiple given address and return a transaction id.
     *
     * @param {Record<string, number>} amounts Dictionary/map with individual addresses and amounts
     * @param {string[]} subtractfeefrom Array of addresses from which fee needs to be deducted.
     * @param {SendManyOptions} options
     * @param {string} [options.comment] A comment
     * @param {boolean} [options.replaceable] Allow this transaction to be replaced by a transaction with higher fees via BIP 125
     * @param {number} [options.confTarget] Confirmation target (in blocks)
     * @param {Mode} [options.estimateMode] The fee estimate mode, must be one of (Mode.UNSET, Mode.ECONOMICAL, Mode.CONSERVATIVE)
     * @return {Promise<string>} hex string of the transaction
     */
    sendMany(amounts, subtractfeefrom = [], options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { comment = '', replaceable = false, confTarget = 6, estimateMode = Mode.UNSET } = options;
            const dummy = ''; // Must be set to '' for backward compatibality.
            const minconf = 0; // Ignored dummy value
            return yield this.client.call('sendmany', [
                dummy, amounts, minconf, comment, subtractfeefrom,
                replaceable, confTarget, estimateMode
            ], 'bignumber');
        });
    }
    /**
     * Reveals the private key corresponding to an address.
     *
     * @param {string} address The DFI address for the private key.
     * @return {Promise<string>}
     */
    dumpPrivKey(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('dumpprivkey', [address], 'number');
        });
    }
    /**
     * Adds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.
     *
     * @param {string} privkey The private key (see dumpprivkey)
     * @param {string}  [label=""] current label if address exists, otherwise "".
     * @param {boolean} [rescan=true] Rescan the wallet for transactions
     */
    importPrivKey(privkey, label = '', rescan = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('importprivkey', [privkey, label, rescan], 'number');
        });
    }
    /**
     * Get detailed information about in-wallet transaction
     *
     * @param {string} txid transaction id
     * @param {boolean} includeWatchOnly optional, default = true
     * @return {Promise<InWalletTransaction>}
     */
    getTransaction(txid, includeWatchOnly = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('gettransaction', [txid, includeWatchOnly], { amount: 'bignumber' });
        });
    }
    /**
     * Returns a list of currently loaded wallets.
     * For full information on the wallet, use 'getwalletinfo'
     *
     * @return {Promise<string[]>}
     */
    listWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listwallets', [], 'number');
        });
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=wallet.js.map