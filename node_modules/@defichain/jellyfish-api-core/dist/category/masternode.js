"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Masternode = exports.MasternodeTimeLock = exports.MasternodeState = void 0;
var MasternodeState;
(function (MasternodeState) {
    MasternodeState["PRE_ENABLED"] = "PRE_ENABLED";
    MasternodeState["ENABLED"] = "ENABLED";
    MasternodeState["PRE_RESIGNED"] = "PRE_RESIGNED";
    MasternodeState["RESIGNED"] = "RESIGNED";
    MasternodeState["PRE_BANNED"] = "PRE_BANNED";
    MasternodeState["BANNED"] = "BANNED";
    MasternodeState["UNKNOWN"] = "UNKNOWN";
})(MasternodeState = exports.MasternodeState || (exports.MasternodeState = {}));
var MasternodeTimeLock;
(function (MasternodeTimeLock) {
    MasternodeTimeLock["FIVE_YEAR"] = "FIVEYEARTIMELOCK";
    MasternodeTimeLock["TEN_YEAR"] = "TENYEARTIMELOCK";
})(MasternodeTimeLock = exports.MasternodeTimeLock || (exports.MasternodeTimeLock = {}));
/**
 * Masternode RPCs for DeFi Blockchain
 */
class Masternode {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a masternode creation transaction with given owner and operator addresses.
     *
     * @param {string} ownerAddress Any valid address for keeping collateral amount
     * @param {string} [operatorAddress]  Masternode operator auth address (P2PKH only, unique). If empty, owner address will be used.
     * @param {CreateMasternodeOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid] The transaction id
     * @param {string} [options.utxos.vout] The output number
     * @param {MasternodeTimeLock} [options.timelock] specify a fix period (5 or 10 years) lock which cannot be resigned and cannot spend the collateral
     * @return {Promise<string>}
     */
    createMasternode(ownerAddress, operatorAddress, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = [
                ownerAddress,
                operatorAddress !== null && operatorAddress !== void 0 ? operatorAddress : ownerAddress,
                options.utxos,
                ...(options.timelock !== undefined ? [options.timelock] : [])
            ];
            return yield this.client.call('createmasternode', params, 'number');
        });
    }
    /**
     * Returns information about multiple masternodes.
     *
     * @param {MasternodePagination} pagination
     * @param {string} [pagination.start]
     * @param {boolean} [pagination.including_start = true] Include starting position.
     * @param {string} [pagination.limit = 100] Maximum number of orders to return.
     * @param {boolean} [verbose = true] Flag for verbose list. Only ids are returned when false.
     * @return {Promise<MasternodeResult>}
     */
    listMasternodes(pagination = {
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listmasternodes', [pagination, verbose], 'number');
        });
    }
    /**
     * Returns information about a single masternode
     *
     * @param {string} masternodeId The masternode's id.
     * @return {Promise<MasternodeResult>}
     */
    getMasternode(masternodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmasternode', [masternodeId], 'number');
        });
    }
    /**
     * Creates a masternode creation transaction with given owner and operator addresses.
     *
     * @param {MasternodeBlock} identifier
     * @param {string} [identifier.id] Masternode's id.
     * @param {string} [identifier.ownerAddress] Masternode owner address.
     * @param {string} [identifier.operatorAddress]  Masternode operator address.
     * @param {number} [depth] Maximum depth, from the genesis block is the default.
     * @return {Promise<MasternodeResult<string>>}
     */
    getMasternodeBlocks(identifier, depth) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmasternodeblocks', [identifier, depth], 'number');
        });
    }
    /**
     * Creates a transaction resigning a masternode.
     *
     * @param {string} masternodeId The masternode's id.
     * @param {UTXO[]} [utxos = []] Array of specified utxos to spend.
     * @param {string} [utxos.txid] The transaction id.
     * @param {number} [utxos.vout] The output number.
     * @return {Promise<string>} Resignation Transaction.
     */
    resignMasternode(masternodeId, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('resignmasternode', [masternodeId, utxos], 'number');
        });
    }
    /**
     * Set special governance variables
     *
     * @param {Record<string, any>} input json object
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {string} [utxos.vout] The output number
     * @return {Promise<string>} hash
     *
     */
    setGov(input, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setgov', [input, utxos], 'number');
        });
    }
    /**
     * Set special governance variables with activation height specified
     *
     * @param {Record<string, any>} input json object
     * @param {number} activationHeight
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {string} [utxos.vout] The output number
     * @return {Promise<string>} hash
     *
     */
    setGovHeight(input, activationHeight, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setgovheight', [input, activationHeight, utxos], 'number');
        });
    }
    /**
     * Get information about governance variable
     *
     * @param {string} name governance name
     * @return {Promise<Record<string, any>} governance information as json object
     */
    getGov(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getgov', [name], 'bignumber');
        });
    }
    /**
     * List all governance variables together if any with activation height
     *
     * @example
     * [
     *   [ { govVarKey: value }, { <activation height number>: value } ],
     *   [ { govVarKey2: value }, { <activation height number>: value } ]
     * ]
     *
     * @returns {Promise<Array<Array<Record<string, any>>>>}
     */
    listGovs() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listgovs', [], 'bignumber');
        });
    }
    /**
     * Checks that custom transaction was affected on chain
     *
     * @param {string} transactionId transaction hash
     * @param {number} blockHeight height of block which contain transaction
     * @return {Promise<boolean>} indicate that custom transaction was affected on chain
     */
    isAppliedCustomTransaction(transactionId, blockHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('isappliedcustomtx', [transactionId, blockHeight], 'number');
        });
    }
    /**
     * Returns the auth and confirm anchor masternode teams at current or specified height
     *
     * @param {number} blockHeight The height of block which contain tx
     * @returns {Promise<AnchorTeamResult>}
     */
    getAnchorTeams(blockHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getanchorteams', [blockHeight], 'number');
        });
    }
    /**
     * Returns number of unique masternodes in the last specified number of blocks.
     *
     * @param {number} [blockCount=20160] The number of blocks to check for unique masternodes.
     * @return {Promise<number>} Number of unique masternodes seen
     */
    getActiveMasternodeCount(blockCount = 20160) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getactivemasternodecount', [blockCount], 'number');
        });
    }
    /**
     * Returns an array of anchors if any
     * @return Promise<MasternodeResult<MasternodeAnchor>>
     */
    listAnchors() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listanchors', [], 'number');
        });
    }
}
exports.Masternode = Masternode;
//# sourceMappingURL=masternode.js.map