import { ApiClient } from '../.';
import BigNumber from 'bignumber.js';
export declare enum Mode {
    UNSET = "UNSET",
    ECONOMICAL = "ECONOMICAL",
    CONSERVATIVE = "CONSERVATIVE"
}
export declare enum AddressType {
    LEGACY = "legacy",
    P2SH_SEGWIT = "p2sh-segwit",
    BECH32 = "bech32"
}
export declare enum ScriptType {
    NONSTANDARD = "nonstandard",
    PUBKEY = "pubkey",
    PUBKEYHASH = "pubkeyhash",
    SCRIPTHASH = "scripthash",
    MULTISIG = "multisig",
    NULLDATA = "nulldata",
    WITNESS_V0_KEYHASH = "witness_v0_keyhash",
    WITNESS_UNKNOWN = "witness_unknown"
}
export declare enum WalletFlag {
    AVOID_REUSE = "avoid_reuse"
}
export declare enum BIP125 {
    YES = "yes",
    NO = "no",
    UNKNOWN = "unknown"
}
export declare enum InWalletTransactionCategory {
    SEND = "send",
    RECEIVE = "receive",
    GENERATE = "generate",
    IMMATURE = "immature",
    ORPHAN = "orphan"
}
/**
 * Wallet RPCs for DeFi Blockchain
 */
export declare class Wallet {
    private readonly client;
    constructor(client: ApiClient);
    /**
     * Returns the total available balance in wallet.
     *
     * @param {number} minimumConfirmation to include transactions confirmed at least this many times
     * @param {boolean} includeWatchOnly for watch-only wallets
     * @return Promise<BigNumber>
     */
    getBalance(minimumConfirmation?: number, includeWatchOnly?: boolean): Promise<BigNumber>;
    /**
     * Identical to getBalance to get untrusted pending balance
     *
     * @return Promise<BigNumber>
     */
    getUnconfirmedBalance(): Promise<BigNumber>;
    /**
     * Returns an object with all balances.
     *
     * @return {Promise<WalletBalances>}
     */
    getBalances(): Promise<WalletBalances>;
    /**
     * Get list of UTXOs in wallet.
     *
     * @param {number} minimumConfirmation default = 1, to filter
     * @param {number} maximumConfirmation default = 9999999, to filter
     * @param {ListUnspentOptions} [options]
     * @param {string[]} [options.addresses] to filter
     * @param {boolean} [options.includeUnsafe=true] default = true, include outputs that are not safe to spend
     * @param {ListUnspentQueryOptions} [options.queryOptions]
     * @param {number} [options.queryOptions.minimumAmount] default = 0, minimum value of each UTXO
     * @param {number} [options.queryOptions.maximumAmount] default is 'unlimited', maximum value of each UTXO
     * @param {number} [options.queryOptions.maximumCount] default is 'unlimited', maximum number of UTXOs
     * @param {number} [options.queryOptions.minimumSumAmount] default is 'unlimited', minimum sum valie of all UTXOs
     * @param {string} [options.queryOptions.tokenId] default is 'all', filter by token
     * @return {Promise<UTXO[]>}
     */
    listUnspent(minimumConfirmation?: number, maximumConfirmation?: number, options?: ListUnspentOptions): Promise<UTXO[]>;
    /**
     * Create a new wallet
     *
     * @param {string} walletName
     * @param {boolean} disablePrivateKeys
     * @param {CreateWalletOptions} [options]
     * @param {boolean} [options.blank]
     * @param {string} [options.passphrase]
     * @param {boolean} [options.avoidReuse]
     * @return {Promise<CreateWalletResult>}
     */
    createWallet(walletName: string, disablePrivateKeys?: boolean, options?: CreateWalletOptions): Promise<CreateWalletResult>;
    /**
     * Return object containing various wallet state info
     *
     * @return {Promise<WalletInfo>}
     */
    getWalletInfo(): Promise<WalletInfo>;
    /**
     * Change the state of the given wallet flag for a wallet
     *
     * @param {WalletFlag} flag to change. eg: avoid_reuse
     * @param {boolean} value optional, default = true
     * @return {Promise<WalletFlagResult>}
     */
    setWalletFlag(flag: WalletFlag, value?: boolean): Promise<WalletFlagResult>;
    /**
     * Returns a new DeFi address for receiving payments.
     * If 'label' is specified, it's added to the address book
     * so payments received with the address will be associated with 'label'
     *
     * @param {string} label for address to be linked to. It can also be set as empty string
     * @param {AddressType} addressType to use, eg: legacy, p2sh-segwit, bech32
     * @return {Promise<string>}
     */
    getNewAddress(label?: string, addressType?: AddressType): Promise<string>;
    /**
     * Validate and return information about the given DFI address
     *
     * @param {string} address
     * @return {Promise<ValidateAddressResult>}
     */
    validateAddress(address: string): Promise<ValidateAddressResult>;
    /**
     * Return information about the given address
     *
     * @param {string} address
     * @return {Promise<AddressInfo>}
     */
    getAddressInfo(address: string): Promise<AddressInfo>;
    /**
     * Send an amount to given address and return a transaction id
     *
     * @param {string} address
     * @param {number} amount
     * @param {SendToAddressOptions} [options]
     * @param {string} [options.comment]
     * @param {string} [options.commentTo]
     * @param {boolean} [options.subtractFeeFromAmount]
     * @param {boolean} [options.replaceable]
     * @param {number} [options.confTarget]
     * @param {Mode} [options.estimateMode]
     * @param {boolean} [options.avoidReuse]
     * @return {Promise<string>}
     */
    sendToAddress(address: string, amount: number, options?: SendToAddressOptions): Promise<string>;
    /**
     * Lists groups of addresses which have had their common ownership made public
     * by common use as inputs or as the resulting change in past transactions
     *
     * @return {Promise<any[][][]>}
     */
    listAddressGroupings(): Promise<any[][][]>;
    /**
     * Send given amounts to multiple given address and return a transaction id.
     *
     * @param {Record<string, number>} amounts Dictionary/map with individual addresses and amounts
     * @param {string[]} subtractfeefrom Array of addresses from which fee needs to be deducted.
     * @param {SendManyOptions} options
     * @param {string} [options.comment] A comment
     * @param {boolean} [options.replaceable] Allow this transaction to be replaced by a transaction with higher fees via BIP 125
     * @param {number} [options.confTarget] Confirmation target (in blocks)
     * @param {Mode} [options.estimateMode] The fee estimate mode, must be one of (Mode.UNSET, Mode.ECONOMICAL, Mode.CONSERVATIVE)
     * @return {Promise<string>} hex string of the transaction
     */
    sendMany(amounts: Record<string, number>, subtractfeefrom?: string[], options?: SendManyOptions): Promise<string>;
    /**
     * Reveals the private key corresponding to an address.
     *
     * @param {string} address The DFI address for the private key.
     * @return {Promise<string>}
     */
    dumpPrivKey(address: string): Promise<string>;
    /**
     * Adds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.
     *
     * @param {string} privkey The private key (see dumpprivkey)
     * @param {string}  [label=""] current label if address exists, otherwise "".
     * @param {boolean} [rescan=true] Rescan the wallet for transactions
     */
    importPrivKey(privkey: string, label?: string, rescan?: boolean): Promise<void>;
    /**
     * Get detailed information about in-wallet transaction
     *
     * @param {string} txid transaction id
     * @param {boolean} includeWatchOnly optional, default = true
     * @return {Promise<InWalletTransaction>}
     */
    getTransaction(txid: string, includeWatchOnly?: boolean): Promise<InWalletTransaction>;
    /**
     * Returns a list of currently loaded wallets.
     * For full information on the wallet, use 'getwalletinfo'
     *
     * @return {Promise<string[]>}
     */
    listWallets(): Promise<string[]>;
}
export interface UTXO {
    txid: string;
    vout: number;
    address: string;
    label: string;
    scriptPubKey: string;
    amount: BigNumber;
    tokenId: number;
    confirmations: number;
    redeemScript: number;
    witnessScript: number;
    spendable: boolean;
    solvable: boolean;
    reused: string;
    desc: string;
    safe: boolean;
}
export interface ListUnspentOptions {
    addresses?: string[];
    includeUnsafe?: boolean;
    queryOptions?: ListUnspentQueryOptions;
}
export interface ListUnspentQueryOptions {
    minimumAmount?: number;
    maximumAmount?: number;
    maximumCount?: number;
    minimumSumAmount?: number;
    tokenId?: string;
}
export interface CreateWalletOptions {
    blank?: boolean;
    passphrase?: string;
    avoidReuse?: boolean;
}
export interface SendToAddressOptions {
    comment?: string;
    commentTo?: string;
    subtractFeeFromAmount?: boolean;
    replaceable?: boolean;
    confTarget?: number;
    estimateMode?: Mode;
    avoidReuse?: boolean;
}
export interface SendManyOptions {
    comment?: string;
    replaceable?: boolean;
    confTarget?: number;
    estimateMode?: Mode;
}
export interface CreateWalletResult {
    name: string;
    warning: string;
}
export interface WalletInfo {
    walletname: string;
    walletversion: number;
    balance: BigNumber;
    unconfirmed_balance: BigNumber;
    immature_balance: BigNumber;
    txcount: number;
    keypoololdest: number;
    keypoolsize: number;
    keypoolsize_hd_internal: number;
    unlocked_until: number;
    paytxfee: BigNumber;
    hdseedid: string;
    private_keys_enabled: boolean;
    avoid_reuse: boolean;
    scanning: {
        duration: number;
        progress: number;
    };
}
export interface ValidateAddressResult {
    isvalid: boolean;
    address: string;
    scriptPubKey: string;
    isscript: boolean;
    iswitness: boolean;
    witness_version: number;
    witness_program: string;
}
export interface AddressInfo {
    address: string;
    scriptPubKey: string;
    ismine: boolean;
    iswatchonly: boolean;
    solvable: boolean;
    desc: string;
    isscript: boolean;
    ischange: true;
    iswitness: boolean;
    witness_version: number;
    witness_program: string;
    script: ScriptType;
    hex: string;
    pubkeys: string[];
    sigsrequired: number;
    pubkey: string;
    embedded: {
        address: string;
        scriptPubKey: string;
        isscript: boolean;
        iswitness: boolean;
        witness_version: number;
        witness_program: string;
        script: ScriptType;
        hex: string;
        sigsrequired: number;
        pubkey: string;
        pubkeys: string[];
    };
    iscompressed: boolean;
    label: string;
    timestamp: number;
    hdkeypath: string;
    hdseedid: string;
    hdmasterfingerprint: string;
    labels: Label[];
}
export interface Label {
    name: string;
    purpose: string;
}
export interface WalletFlagResult {
    flag_name: string;
    flag_state: boolean;
    warnings: string;
}
export interface InWalletTransaction {
    amount: BigNumber;
    fee: number;
    confirmations: number;
    blockhash: string;
    blockindex: number;
    blocktime: number;
    txid: string;
    time: number;
    timereceived: number;
    bip125replaceable?: BIP125;
    details: InWalletTransactionDetail[];
    hex: string;
}
export interface InWalletTransactionDetail {
    address: string;
    category: InWalletTransactionCategory;
    amount: number;
    label: string;
    vout: number;
    fee: number;
    abandoned: boolean;
}
export interface WalletBalances {
    mine: WalletMineBalances;
    watchonly?: WalletWatchOnlyBalances;
}
export interface WalletMineBalances {
    trusted: BigNumber;
    untrusted_pending: BigNumber;
    immature: BigNumber;
    used?: BigNumber;
}
export interface WalletWatchOnlyBalances {
    trusted: BigNumber;
    untrusted_pending: BigNumber;
    immature: BigNumber;
}
//# sourceMappingURL=wallet.d.ts.map