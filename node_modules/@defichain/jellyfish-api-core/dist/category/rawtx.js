"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawTx = exports.SigHashType = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
var SigHashType;
(function (SigHashType) {
    SigHashType["ALL"] = "ALL";
    SigHashType["NONE"] = "NONE";
    SigHashType["SINGLE"] = "SINGLE";
    SigHashType["ALL_ANYONECANPAY"] = "ALL|ANYONECANPAY";
    SigHashType["NONE_ANYONECANPAY"] = "NONE|ANYONECANPAY";
    SigHashType["SINGLE_ANYONECANPAY"] = "SINGLE|ANYONECANPAY";
})(SigHashType = exports.SigHashType || (exports.SigHashType = {}));
/**
 * RawTransaction RPCs for DeFi Blockchain
 */
class RawTx {
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a transaction spending the given inputs and creating new outputs that returns a hex-encoded raw transaction.
     * Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
     *
     * @param {CreateRawTxIn[]} inputs array of inputs
     * @param {CreateRawTxOut[]} outputs array with outputs
     * @param {CreateRawTxOptions} [options]
     * @param {number} [options.locktime] Non-0 value also locktime-activates inputs
     * @param {boolean} [options.replaceable] Marks this transaction as BIP125-replaceable
     * @return {Promise<string>} hex string of the transaction
     */
    createRawTransaction(inputs, outputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { locktime = 0, replaceable = false } = options;
            return yield this.client.call('createrawtransaction', [
                inputs, outputs, locktime, replaceable
            ], 'number');
        });
    }
    /**
     * Sign inputs for raw transaction (serialized, hex-encoded), providing an array of base58-encoded private keys that
     * will be the keys used to sign the transaction. An optional array of previous transaction outputs that this
     * transaction depends on but may not yet be in the blockchain.
     *
     * @param {string} rawTx unsigned raw transaction
     * @param {string[]} privKeys array of base58-encoded private keys for signing (WIF)
     * @param {SignRawTxWithKeyOptions} [options]
     * @param {SigHashType} [options.sigHashType] the signature hash type to use
     * @param {SignRawTxWithKeyPrevTx[]} [options.prevTxs] array of previous dependent transaction outputs
     * @return {Promise<SignRawTxWithKeyResult>}
     */
    signRawTransactionWithKey(rawTx, privKeys, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { prevTxs = [], sigHashType = SigHashType.ALL } = options;
            return yield this.client.call('signrawtransactionwithkey', [
                rawTx, privKeys, prevTxs, sigHashType
            ], 'number');
        });
    }
    /**
     * Returns result of mempool acceptance tests indicating if raw transaction would be accepted by mempool.
     * This checks if the transaction violates the consensus or policy rules. The fee rate is expressed in DFI/kB,
     * using the vSize of the transaction.
     *
     * @param {string} signedTx signed raw transaction
     * @param {BigNumber} maxFeeRate Reject transactions whose fee rate is higher than the specified value. in DFI/kB
     * @return {Promise<TestMempoolAcceptResult>} transaction mempool accept result
     * @see sendRawTransaction
     * @see createRawTransaction
     * @see signRawTransactionWithKey
     */
    testMempoolAccept(signedTx, maxFeeRate = new bignumber_js_1.default('0')) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.client.call('testmempoolaccept', [
                [signedTx], maxFeeRate
            ], 'number');
            return results[0];
        });
    }
    /**
     * Submit a raw transaction (serialized, hex-encoded) to the connected node and network. The transaction will be sent
     * unconditionally to all peers, so using this for manual rebroadcast may degrade privacy by leaking the transaction's
     * origin, as nodes will normally not rebroadcast non-wallet transactions already in their mempool.
     *
     * @param {string} signedTx signed raw transaction
     * @param {BigNumber} maxFeeRate Reject transactions whose fee rate is higher than the specified value. in DFI/kB
     * @return {Promise<string>} transaction hash in hex
     * @see testMempoolAccept
     * @see createRawTransaction
     * @see signRawTransactionWithKey
     */
    sendRawTransaction(signedTx, maxFeeRate = new bignumber_js_1.default('0')) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('sendrawtransaction', [
                signedTx, maxFeeRate
            ], 'number');
        });
    }
    /**
     * Get raw transaction
     *
     * @param {string} txid transaction id
     * @param {boolean} [verbose=false] true will return object information, false/omitted will return hex-encoded data
     * @param {string} [blockHash] mempool transaction is returned by default. If blockHash is specified then will get transaction in block.
     * @return {Promise<string | RawTransaction>}
     */
    getRawTransaction(txid, verbose, blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getrawtransaction', [txid, verbose, blockHash], 'number');
        });
    }
}
exports.RawTx = RawTx;
//# sourceMappingURL=rawtx.js.map