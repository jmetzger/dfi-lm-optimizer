"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcClient = exports.defaultOptions = void 0;
const jellyfish_api_core_1 = require("@defichain/jellyfish-api-core");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const abort_controller_1 = __importDefault(require("abort-controller"));
/**
 * JsonRpcClient default client options
 */
exports.defaultOptions = {
    timeout: 60000,
    headers: undefined
};
/**
 * A JSON-RPC client implementation for connecting to a DeFiChain node.
 */
class JsonRpcClient extends jellyfish_api_core_1.ApiClient {
    /**
     * Construct a Jellyfish client to connect to a DeFiChain node via JSON-RPC.
     *
     * @param {string} url endpoint
     * @param {ClientOptions} [options] Optional ClientOptions
     * timeout: default to 60000ms
     * headers: none
     */
    constructor(url, options) {
        super();
        this.url = url;
        this.options = Object.assign(exports.defaultOptions, options !== null && options !== void 0 ? options : {});
    }
    /**
     * Implements JSON-RPC 1.0 specification for ApiClient
     */
    call(method, params, precision) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = JsonRpcClient.stringify(method, params);
            const response = yield this.fetchTimeout(body);
            const text = yield response.text();
            switch (response.status) {
                case 401:
                case 403:
                case 404:
                case 422:
                    throw new jellyfish_api_core_1.ClientApiError(`${response.status} - ${response.statusText}`);
                case 200:
                default:
                    return JsonRpcClient.parse(method, text, precision);
            }
        });
    }
    static stringify(method, params) {
        return jellyfish_api_core_1.JellyfishJSON.stringify({
            jsonrpc: '1.0',
            id: Math.floor(Math.random() * 100000000000000),
            method: method,
            params: params
        });
    }
    static parse(method, text, precision) {
        const { result, error } = jellyfish_api_core_1.JellyfishJSON.parse(text, {
            result: precision
        });
        if (error != null) {
            throw new jellyfish_api_core_1.RpcApiError(Object.assign(Object.assign({}, error), { method: method }));
        }
        return result;
    }
    /**
     * Fetch with timeout defined in 'this.options.timeout'
     */
    fetchTimeout(body) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const timeout = (_a = this.options.timeout) !== null && _a !== void 0 ? _a : 60000;
            const controller = new abort_controller_1.default();
            const id = setTimeout(() => controller.abort(), timeout);
            const request = this.fetch(body, controller);
            try {
                const response = yield request;
                clearTimeout(id);
                return response;
            }
            catch (err) {
                if (err.type === 'aborted') {
                    throw new jellyfish_api_core_1.ClientApiError(`request aborted due to set timeout of ${timeout}ms`);
                }
                throw err;
            }
        });
    }
    fetch(body, controller) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield cross_fetch_1.default(this.url, {
                method: 'POST',
                body: body,
                cache: 'no-cache',
                headers: this.options.headers,
                signal: controller.signal
            });
        });
    }
}
exports.JsonRpcClient = JsonRpcClient;
//# sourceMappingURL=index.js.map