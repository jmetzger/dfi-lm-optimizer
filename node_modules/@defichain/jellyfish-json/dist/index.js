"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JellyfishJSON = exports.LosslessNumber = exports.BigNumber = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
exports.BigNumber = bignumber_js_1.default;
const lossless_json_1 = require("lossless-json");
Object.defineProperty(exports, "LosslessNumber", { enumerable: true, get: function () { return lossless_json_1.LosslessNumber; } });
const remap_1 = require("./remap");
/**
 * Revive lossless as a type
 */
function reviveLosslessAs(transformer) {
    return (key, value) => {
        if (value instanceof lossless_json_1.LosslessNumber) {
            return transformer(value.toString());
        }
        return value;
    };
}
/**
 * JellyfishJSON allows parsing of JSON with 'lossless', 'bignumber' and 'number' numeric precision.
 */
exports.JellyfishJSON = {
    /**
     * Precision parses all numeric value as the given Precision.
     *
     * PrecisionPath selectively remap each numeric value based on the mapping provided,
     * defaults to number if precision is not provided for the key. This works deeply.
     *
     * @param {string} text JSON string to parse into object.
     * @param {Precision | PrecisionPath} precision Numeric precision to parse payload as.
     */
    parse(text, precision) {
        if (typeof precision === 'string') {
            switch (precision) {
                case 'lossless':
                    return lossless_json_1.parse(text);
                case 'bignumber':
                    return lossless_json_1.parse(text, reviveLosslessAs(string => new bignumber_js_1.default(string)));
                case 'number':
                    return lossless_json_1.parse(text, reviveLosslessAs(string => Number(string)));
                default:
                    throw new Error(`JellyfishJSON.parse ${precision} precision is not supported`);
            }
        }
        const losslessObj = lossless_json_1.parse(text);
        return remap_1.remap(losslessObj, precision);
    },
    /**
     * @param {any} value object to stringify, with no risk of losing precision.
     */
    stringify(value) {
        function replacer(key, value) {
            if (value instanceof bignumber_js_1.default) {
                return new lossless_json_1.LosslessNumber(value.toString());
            }
            return value;
        }
        return lossless_json_1.stringify(value, replacer);
    }
};
//# sourceMappingURL=index.js.map