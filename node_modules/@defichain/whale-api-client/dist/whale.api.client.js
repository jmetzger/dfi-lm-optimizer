"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleApiClient = void 0;
require("url-search-params-polyfill");
const abort_controller_1 = __importDefault(require("abort-controller"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const version_1 = __importDefault(require("./version"));
const errors_1 = require("./errors");
const whale_api_response_1 = require("./whale.api.response");
const address_1 = require("./api/address");
const poolpairs_1 = require("./api/poolpairs");
const rpc_1 = require("./api/rpc");
const transactions_1 = require("./api/transactions");
const tokens_1 = require("./api/tokens");
const masternodes_1 = require("./api/masternodes");
const blocks_1 = require("./api/blocks");
const oracles_1 = require("./api/oracles");
const prices_1 = require("./api/prices");
const stats_1 = require("./api/stats");
const rawtx_1 = require("./api/rawtx");
const fee_1 = require("./api/fee");
const loan_1 = require("./api/loan");
/**
 * WhaleApiClient default options
 */
const DEFAULT_OPTIONS = {
    url: 'https://ocean.defichain.com',
    timeout: 60000,
    version: version_1.default,
    network: 'mainnet'
};
class WhaleApiClient {
    constructor(options) {
        this.options = options;
        this.rpc = new rpc_1.Rpc(this);
        this.address = new address_1.Address(this);
        this.poolpairs = new poolpairs_1.PoolPairs(this);
        this.transactions = new transactions_1.Transactions(this);
        this.tokens = new tokens_1.Tokens(this);
        this.masternodes = new masternodes_1.Masternodes(this);
        this.blocks = new blocks_1.Blocks(this);
        this.oracles = new oracles_1.Oracles(this);
        this.prices = new prices_1.Prices(this);
        this.stats = new stats_1.Stats(this);
        this.rawtx = new rawtx_1.Rawtx(this);
        this.fee = new fee_1.Fee(this);
        this.loan = new loan_1.Loan(this);
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.options.url = this.options.url.replace(/\/$/, '');
    }
    /**
     * @param {ApiPagedResponse} response from the previous request for pagination chaining
     */
    paginate(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = response.nextToken;
            if (token === undefined) {
                return new whale_api_response_1.ApiPagedResponse({ data: [] }, response.method, response.endpoint);
            }
            const [path, query] = response.endpoint.split('?');
            if (query === undefined) {
                throw new errors_1.WhaleClientException('endpoint does not contain query params for pagination');
            }
            const params = new URLSearchParams(query);
            params.set('next', token.toString());
            const endpoint = `${path}?${params.toString()}`;
            const apiResponse = yield this.requestAsApiResponse(response.method, endpoint);
            return new whale_api_response_1.ApiPagedResponse(apiResponse, response.method, endpoint);
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {number} [size] of the list
     * @param {string} [next] token for pagination
     * @return {ApiPagedResponse} data list in the JSON response body for pagination query
     * @see {paginate(ApiPagedResponse)} for pagination query chaining
     */
    requestList(method, path, size, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams();
            params.set('size', size.toString());
            if (next !== undefined) {
                params.set('next', next);
            }
            const endpoint = `${path}?${params.toString()}`;
            const response = yield this.requestAsApiResponse(method, endpoint);
            return new whale_api_response_1.ApiPagedResponse(response, method, endpoint);
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {any} [object] JSON to send in request
     * @return {T} data object in the JSON response body
     */
    requestData(method, path, object) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.requestAsApiResponse(method, path, object);
            return response.data;
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {object} [object] JSON to send in request
     * @return {WhaleApiResponse} parsed structured JSON response
     */
    requestAsApiResponse(method, path, object) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = object !== undefined ? JSON.stringify(object) : undefined;
            const raw = yield this.requestAsString(method, path, json);
            const response = JSON.parse(raw.body);
            errors_1.raiseIfError(response);
            return response;
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {object} [body] in string in request
     * @return {ResponseAsString} as JSON string (RawResponse)
     */
    requestAsString(method, path, body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url: urlString, version, network, timeout } = this.options;
            const url = `${urlString}/${version}/${network}/${path}`;
            const controller = new abort_controller_1.default();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = yield _fetch(method, url, controller, body);
                clearTimeout(id);
                return response;
            }
            catch (err) {
                if (err.type === 'aborted') {
                    /* eslint-disable @typescript-eslint/no-non-null-assertion */
                    throw new errors_1.WhaleClientTimeoutException(timeout);
                }
                throw err;
            }
        });
    }
}
exports.WhaleApiClient = WhaleApiClient;
/**
 * Generic method for making http requests
 *
 * @param {Method} method for the endpoint
 * @param {string} url to fetch
 * @param {AbortController} controller for aborting request
 * @param {string} body of the request
 * @returns {Promise<ResponseAsString>}
 */
function _fetch(method, url, controller, body) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield cross_fetch_1.default(url, {
            method: method,
            headers: method !== 'GET' ? { 'Content-Type': 'application/json' } : {},
            body: body,
            cache: 'no-cache',
            signal: controller.signal
        });
        return {
            status: response.status,
            body: yield response.text()
        };
    });
}
