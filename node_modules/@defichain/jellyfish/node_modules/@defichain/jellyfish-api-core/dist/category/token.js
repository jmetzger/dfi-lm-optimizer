"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = void 0;
/**
 * Token RPCs for DeFi Blockchain
 */
class Token {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a token with given metadata
     *
     * @param {CreateTokenMetadata} metadata
     * @param {string} metadata.symbol token's symbol (unique)
     * @param {string} metadata.name token's name (unique)
     * @param {boolean} metadata.isDAT default = false
     * @param {boolean} metadata.mintable default = true
     * @param {boolean} metadata.tradeable default = true
     * @param {string} metadata.collateralAddress for keeping collateral amount
     * @param {UTXO[]} utxos array of specific UTXOs to spend
     * @param {string} utxos.txid
     * @param {number} utxos.vout
     * @return {Promise<string>}
     */
    createToken(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultMetadata = {
                isDAT: false,
                mintable: true,
                tradeable: true
            };
            return yield this.client.call('createtoken', [Object.assign(Object.assign({}, defaultMetadata), metadata), utxos], 'number');
        });
    }
    /**
     * Updates a token with given metadata
     *
     * @param {string} token symbolKey, id ror creation tx
     * @param {UpdateTokenMetadata} [metadata]
     * @param {string} [metadata.symbol]
     * @param {string} [metadata.name]
     * @param {boolean} [metadata.isDAT]
     * @param {boolean} [metadata.mintable]
     * @param {boolean} [metadata.tradeable]
     * @param {boolean} [metadata.finalize]
     * @return {Promise<string>}
     */
    updateToken(token, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updatetoken', [token, metadata], 'number');
        });
    }
    /**
     * Returns information about tokens
     *
     * @param {TokenPagination} pagination
     * @param {number} pagination.start
     * @param {boolean} pagination.including_start
     * @param {number} pagination.limit
     * @param {boolean} verbose
     * @return {Promise<TokenResult>}
     */
    listTokens(pagination = {
        start: 0,
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listtokens', [pagination, verbose], 'bignumber');
        });
    }
    /**
     * Return information about token
     *
     * @param {string} symbolKey
     * @return {Promise<TokenResult>}
     */
    getToken(symbolKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note(canonbrother): only 'limit' and 'minted' is bignumber
            // but the 'return' contains random id which is not be able to map precision exactly
            // precision: { '0': limit: 'bignumber', minted: 'bignumber'}
            return yield this.client.call('gettoken', [symbolKey], 'bignumber');
        });
    }
    /**
     * Creates a transaction to mint tokens.
     *
     * @param {string} amountToken formatted as `${number}@${string}`
     * @param {UTXO[]} [utxos = []]
     * @param {string} [utxos.txid]
     * @param {number} [utxos.vout]
     * @return {Promise<string>}
     */
    mintTokens(amountToken, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('minttokens', [amountToken, utxos], 'number');
        });
    }
}
exports.Token = Token;
//# sourceMappingURL=token.js.map