"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Spv = exports.HTLC_MINIMUM_BLOCK_COUNT = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
exports.HTLC_MINIMUM_BLOCK_COUNT = 9;
/**
 * SPV RPCs for Bitcoin Blockchain
 */
class Spv {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates and adds a Bitcoin address to the SPV wallet.
     *
     * @return {Promise<string>} Returns a new Bitcoin address
     */
    getNewAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_getnewaddress', [], 'number');
        });
    }
    /**
     * Returns a Bitcoin address's public key.
     *
     * @param {string} address Bitcoin address
     * @return {Promise<string>} Public key
     */
    getAddressPubKey(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_getaddresspubkey', [address], 'number');
        });
    }
    /**
     * List balances by receiving address.
     *
     * @param {string} [minConfirmation=1] The minimum number of confirmations
     * @param {string} [address] Filter by address
     * @return {Promise<ReceivedByAddressInfo[]>}
     */
    listReceivedByAddress(minConfirmation = 1, address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listreceivedbyaddress', [minConfirmation, address], {
                amount: 'bignumber'
            });
        });
    }
    /**
     * Send a Bitcoin amount to a given address.
     *
     * @param {string} address Bitcoin address
     * @param {BigNumber} amount Bitcoin amount
     * @param {SpvDefaultOptions} [options]
     * @param {BigNumber} [options.feeRate=10000] Fee rate in satoshis per KB. Minimum is 1000.
     * @return {Promise<SendMessageResult>}
     */
    sendToAddress(address, amount, options = { feeRate: new bignumber_js_1.default('10000') }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_sendtoaddress', [address, amount, options.feeRate], 'bignumber');
        });
    }
    /**
     * Creates a Bitcoin address whose funds can be unlocked with a seed or as a refund.
     *
     * @param {string} receiverPubKey The public key of the possessor of the seed
     * @param {string} ownerPubKey The public key of the recipient of the refund
     * @param {CreateHtlcOptions} options
     * @param {string} options.timeout  Timeout of the contract (denominated in blocks) relative to its placement in the blockchain. Minimum 9. See HTLC_MINIMUM_BLOCK_COUNT
     * @param {string} [options.seedhash] SHA256 hash of the seed. If none provided one will be generated
     * @return {Promise<CreateHtlcResult>}
     */
    createHtlc(receiverPubKey, ownerPubKey, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_createhtlc', [receiverPubKey, ownerPubKey, options.timeout, options.seedhash], 'number');
        });
    }
    /**
     * Decode and return value in a HTLC redeemscript.
     *
     * @param {string} redeemScript HTLC redeem script
     * @return {Promise<DecodeHtlcResult>}
     */
    decodeHtlcScript(redeemScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_decodehtlcscript', [redeemScript], 'number');
        });
    }
    /**
     * Claims all coins in HTLC address.
     *
     * @param {string} scriptAddress HTLC address
     * @param {string} destinationAddress Destination address to send HTLC funds to
     * @param {ClaimHtlcOptions} options
     * @param {string} options.seed HTLC seed
     * @param {BigNumber} [options.feeRate=10000] Fee rate in satoshis per KB. Minimum is 1000.
     * @return {Promise<SendMessageResult>}
     */
    claimHtlc(scriptAddress, destinationAddress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_claimhtlc', [scriptAddress, destinationAddress, options.seed, options.feeRate], 'bignumber');
        });
    }
    /**
     * Returns the HTLC secret if available.
     *
     * @param {string} address HTLC address
     * @return {Promise<string>} HTLC secret
     */
    getHtlcSeed(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_gethtlcseed', [address], 'number');
        });
    }
    /**
     * Refunds all coins in HTLC address.
     * Can be used after the timeout threshold set in createHtlc. See https://en.bitcoin.it/wiki/BIP_0199
     *
     * @param {string} scriptAddress HTLC address
     * @param {string} destinationAddress Destination for funds in the HTLC
     * @param {SpvDefaultOptions} [options]
     * @param {BigNumber} [options.feeRate=10000] Fee rate in satoshis per KB. Minimum is 1000.
     * @return {Promise<SendMessageResult>}
     */
    refundHtlc(scriptAddress, destinationAddress, options = { feeRate: new bignumber_js_1.default('10000') }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_refundhtlc', [scriptAddress, destinationAddress, options.feeRate], 'number');
        });
    }
    /**
     * List all outputs related to HTLC addresses in the wallet.
     *
     * @param {string | undefined} [scriptAddress] HTLC address to filter result
     * @return {Promise<ListHtlcsOutputsResult[]>}
     */
    listHtlcOutputs(scriptAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listhtlcoutputs', [scriptAddress], { amount: 'bignumber' });
        });
    }
    /**
     * List anchor reward confirms
     *
     * @return {Promise<ListAnchorRewardConfirmsResult[]>}
     */
    listAnchorRewardConfirms() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorrewardconfirms', [], 'number');
        });
    }
    /**
     * List unrewarded anchors
     *
     * @return {Promise<ListAnchorsResult[]>}
     */
    listAnchorsUnrewarded() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorsunrewarded', [], 'number');
        });
    }
    /**
     * List anchor rewards
     *
     * @return {Promise<ListAnchorRewardsResult[]>}
     */
    listAnchorRewards() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorrewards', [], 'number');
        });
    }
    /**
     * Create, sign and send anchor tx, using only SPV API
     *
     * @param {CreateAnchorInput[]} createAnchorInputs Info from BTC chain
     * @param {string} createAnchorInput.txid The transaction id of the bitcoin UTXO to spent
     * @param {string} createAnchorInput.vout The output index to spend in UTXO for tx fee
     * @param {number} createAnchorInput.amount Amount of output in satoshis (base unit)
     * @param {string} createAnchorInput.privkey WIF private key of bitcoin for signing this output
     * @param {string} rewardAddress User's P2PKH address (in DeFi chain) for reward
     * @param {CreateAnchorOptions} [options]
     * @param {boolean} [options.send=true] Send it to BTC network
     * @param {BigNumber} [options.feerate=1000] Feerate (satoshis) per KB, default is 1000.
     * @return {Promise<CreateAnchorResult>}
     */
    createAnchor(createAnchorInputs, rewardAddress, options = { send: true, feerate: 1000 }) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign({ send: true, feerate: 1000 }, options);
            return yield this.client.call('spv_createanchor', [createAnchorInputs, rewardAddress, opts.send, opts.feerate], { cost: 'bignumber', estimatedReward: 'bignumber' });
        });
    }
    /**
     * List anchors
     *
     * @param {ListAnchorsOptions} [options]
     * @param {number} [options.minBtcHeight=-1]
     * @param {number} [options.maxBtcHeight=-1]
     * @param {number} [options.minConfs=-1]
     * @param {number} [options.maxConfs=-1]
     * @return {Promise<ListAnchorsResult[]>}
     */
    listAnchors(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign({ minBtcHeight: -1, maxBtcHeight: -1, minConfs: -1, maxConfs: -1 }, options);
            return yield this.client.call('spv_listanchors', [opts.minBtcHeight, opts.maxBtcHeight, opts.minConfs, opts.maxConfs], 'number');
        });
    }
    /**
     * List pending anchors in mempool
     *
     * @return {Promise<ListAnchorsResult[]>}
     */
    listAnchorsPending() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorspending', [], 'number');
        });
    }
    /**
     * List anchor auths
     *
     * @return {Promise<ListAnchorAuthsResult[]>}
     */
    listAnchorAuths() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorauths', [], 'number');
        });
    }
    /**
     * Set last height on BTC chain, use for testing purpose
     *
     * @param {number} height
     * @return {Promise<void>}
     */
    setLastHeight(height) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_setlastheight', [height], 'number');
        });
    }
}
exports.Spv = Spv;
//# sourceMappingURL=spv.js.map