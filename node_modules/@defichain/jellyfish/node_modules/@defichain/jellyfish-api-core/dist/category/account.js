"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = exports.SelectionModeType = exports.DfTxType = exports.OwnerType = void 0;
/**
 * Single account ID (CScript or address) or reserved words,
 * - 'mine' to list history for all owned accounts or
 * - 'all' to list the whole DB
 */
var OwnerType;
(function (OwnerType) {
    OwnerType["MINE"] = "mine";
    OwnerType["ALL"] = "all";
})(OwnerType = exports.OwnerType || (exports.OwnerType = {}));
var DfTxType;
(function (DfTxType) {
    DfTxType["MINT_TOKEN"] = "M";
    DfTxType["POOL_SWAP"] = "s";
    DfTxType["ADD_POOL_LIQUIDITY"] = "l";
    DfTxType["REMOVE_POOL_LIQUIDITY"] = "r";
    DfTxType["UTXOS_TO_ACCOUNT"] = "U";
    DfTxType["ACCOUNT_TO_UTXOS"] = "b";
    DfTxType["ACCOUNT_TO_ACCOUNT"] = "B";
    DfTxType["ANY_ACCOUNTS_TO_ACCOUNTS"] = "a";
    DfTxType["CREATE_MASTERNODE"] = "C";
    DfTxType["RESIGN_MASTERNODE"] = "R";
    DfTxType["CREATE_TOKEN"] = "T";
    DfTxType["UPDATE_TOKEN"] = "N";
    DfTxType["UPDATE_TOKEN_ANY"] = "n";
    DfTxType["CREATE_POOL_PAIR"] = "p";
    DfTxType["UPDATE_POOL_PAIR"] = "u";
    DfTxType["SET_GOV_VARIABLE"] = "G";
    DfTxType["AUTO_AUTH_PREP"] = "A";
    DfTxType["NONE"] = "0";
})(DfTxType = exports.DfTxType || (exports.DfTxType = {}));
var SelectionModeType;
(function (SelectionModeType) {
    SelectionModeType["PIE"] = "pie";
    SelectionModeType["CRUMBS"] = "crumbs";
    SelectionModeType["FORWARD"] = "forward";
})(SelectionModeType = exports.SelectionModeType || (exports.SelectionModeType = {}));
/**
 * Account RPCs for DeFi Blockchain
 */
class Account {
    constructor(client) {
        this.client = client;
    }
    listAccounts(pagination = { limit: 100 }, verbose = true, options = { indexedAmounts: false, isMineOnly: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { indexedAmounts, isMineOnly } = options;
            return yield this.client.call('listaccounts', [pagination, verbose, indexedAmounts, isMineOnly], 'bignumber');
        });
    }
    getAccount(owner, pagination = { limit: 100 }, options = { indexedAmounts: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { indexedAmounts = false } = options;
            return yield this.client.call('getaccount', [owner, pagination, indexedAmounts], 'number');
        });
    }
    getTokenBalances(pagination = { limit: 100 }, indexedAmounts = false, options = { symbolLookup: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { symbolLookup } = options;
            return yield this.client.call('gettokenbalances', [pagination, indexedAmounts, symbolLookup], 'bignumber');
        });
    }
    /**
     * Create a UTXOs to Account transaction submitted to a connected node.
     * Optionally, specific UTXOs to spend to create that transaction.
     *
     * @param {BalanceTransferPayload} payload
     * @param {string} payload[address]
     * @param {UTXO[]} [utxos = []]
     * @param {string} [utxos.txid]
     * @param {number} [utxos.vout]
     * @return {Promise<string>}
     */
    utxosToAccount(payload, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('utxostoaccount', [payload, utxos], 'number');
        });
    }
    /**
     * Create an Account to Account transaction submitted to a connected node.
     * Optionally, specific UTXOs to spend to create that transaction.
     *
     * @param {string} from
     * @param {BalanceTransferPayload} payload
     * @param {string} payload[address]
     * @param {BalanceTransferAccountOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>}
     */
    accountToAccount(from, payload, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('accounttoaccount', [from, payload, options.utxos], 'number');
        });
    }
    /**
     * Create an Account to UXTOS transaction submitted to a connected node.
     * Optionally, specific UTXOs to spend to create that transaction.
     *
     * @param {string} from
     * @param {BalanceTransferPayload} payload
     * @param {string} payload[address]
     * @param {BalanceTransferAccountOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>}
     */
    accountToUtxos(from, payload, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('accounttoutxos', [from, payload, options.utxos], 'number');
        });
    }
    /**
     * Returns information about account history
     *
     * @param {OwnerType | string} [owner=OwnerType.MINE] single account ID (CScript or address) or reserved words 'mine' to list history for all owned accounts or 'all' to list whole DB
     * @param {AccountHistoryOptions} [options]
     * @param {number} [options.maxBlockHeight] Optional height to iterate from (down to genesis block), (default = chaintip).
     * @param {number} [options.depth] Maximum depth, from the genesis block is the default
     * @param {boolean} [options.no_rewards] Filter out rewards
     * @param {string} [options.token] Filter by token
     * @param {DfTxType} [options.txtype] Filter by transaction type. See DfTxType.
     * @param {number} [options.limit=100] Maximum number of records to return, 100 by default
     * @return {Promise<AccountHistory[]>}
     */
    listAccountHistory(owner = OwnerType.MINE, options = {
        limit: 100
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listaccounthistory', [owner, options], 'number');
        });
    }
    /**
     * Returns count of account history
     *
     * @param {OwnerType | string} [owner=OwnerType.MINE] single account ID (CScript or address) or reserved words 'mine' to list history count for all owned accounts or 'all' to list whole DB
     * @param {AccountHistoryCountOptions} [options]
     * @param {boolean} [options.no_rewards] Filter out rewards
     * @param {string} [options.token] Filter by token
     * @param {DfTxType} [options.txtype] Filter by transaction type. See DfTxType.
     * @return {Promise<number>} count of account history
     */
    historyCount(owner = OwnerType.MINE, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('accounthistorycount', [owner, options], 'number');
        });
    }
    /**
     * Creates a transfer transaction from your accounts balances.
     *
     * @param {AddressBalances} from source address as the key, the value is amount formatted as amount@token
     * @param {AddressBalances} to address as the key, the value is amount formatted as amount@token
     * @param {SendTokensOptions} [options = { selectionMode: SelectionModeType.PIE }]
     * @param {SelectionModeType} [options.selectionMode] Account selection mode. If "from" param is empty, it will auto select.
     * @return {Promise<string>}
     */
    sendTokensToAddress(from, to, options = { selectionMode: SelectionModeType.PIE }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('sendtokenstoaddress', [from, to, options.selectionMode], 'number');
        });
    }
    /**
     * Returns information about current anchor bonus, incentive funding, burnt token(s)
     *
     * @return {Promise<CommunityBalanceData>}
     */
    listCommunityBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listcommunitybalances', [], 'bignumber');
        });
    }
    /**
     * Returns information about burn history
     *
     * @param {BurnHistoryOptions} [options]
     * @param {number} [options.maxBlockHeight]  The block height to iterate from.
     * @param {number} [options.depth] Maximum depth, from the genesis block is the default
     * @param {string} [options.token] Filter by token
     * @param {DfTxType} [options.txtype] Filter by transaction type. See DfTxType.
     * @param {number} [options.limit=100] Maximum number of records to return, 100 by default
     * @return {Promise<BurnHistory[]>}
     */
    listBurnHistory(options = {
        limit: 100
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listburnhistory', [options], 'number');
        });
    }
    /**
     * Returns burn address, burnt coin and token information.
     * Requires full acindex for correct amount, tokens and feeburn values.
     *
     * @return {Promise<BurnInfo>}
     */
    getBurnInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getburninfo', [], 'bignumber');
        });
    }
}
exports.Account = Account;
//# sourceMappingURL=account.js.map