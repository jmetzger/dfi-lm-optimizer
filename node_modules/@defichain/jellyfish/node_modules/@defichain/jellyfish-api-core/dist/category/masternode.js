"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Masternode = exports.MasternodeTimeLock = exports.MasternodeState = void 0;
var MasternodeState;
(function (MasternodeState) {
    MasternodeState["PRE_ENABLED"] = "PRE_ENABLED";
    MasternodeState["ENABLED"] = "ENABLED";
    MasternodeState["PRE_RESIGNED"] = "PRE_RESIGNED";
    MasternodeState["RESIGNED"] = "RESIGNED";
    MasternodeState["PRE_BANNED"] = "PRE_BANNED";
    MasternodeState["BANNED"] = "BANNED";
    MasternodeState["UNKNOWN"] = "UNKNOWN";
})(MasternodeState = exports.MasternodeState || (exports.MasternodeState = {}));
var MasternodeTimeLock;
(function (MasternodeTimeLock) {
    MasternodeTimeLock["FIVE_YEAR"] = "FIVEYEARTIMELOCK";
    MasternodeTimeLock["TEN_YEAR"] = "TENYEARTIMELOCK";
})(MasternodeTimeLock = exports.MasternodeTimeLock || (exports.MasternodeTimeLock = {}));
/**
 * Masternode RPCs for DeFi Blockchain
 */
class Masternode {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a masternode creation transaction with given owner and operator addresses.
     *
     * @param {string} ownerAddress Any valid address for keeping collateral amount
     * @param {string} [operatorAddress]  Masternode operator auth address (P2PKH only, unique). If empty, owner address will be used.
     * @param {CreateMasternodeOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid] The transaction id
     * @param {string} [options.utxos.vout] The output number
     * @param {MasternodeTimeLock} [options.timelock] specify a fix period (5 or 10 years) lock which cannot be resigned and cannot spend the collateral
     * @return {Promise<string>}
     */
    createMasternode(ownerAddress, operatorAddress, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            operatorAddress = operatorAddress !== null && operatorAddress !== void 0 ? operatorAddress : ownerAddress;
            const params = [ownerAddress, operatorAddress, options.utxos];
            if (options.timelock !== undefined) {
                params.push(options.timelock);
            }
            return yield this.client.call('createmasternode', params, 'number');
        });
    }
    /**
     * Returns information about multiple masternodes.
     *
     * @param {MasternodePagination} pagination
     * @param {string} [pagination.start]
     * @param {boolean} [pagination.including_start = true] Include starting position.
     * @param {string} [pagination.limit = 100] Maximum number of orders to return.
     * @param {boolean} [verbose = true] Flag for verbose list. Only ids are returned when false.
     * @return {Promise<MasternodeResult<T>>}
     */
    listMasternodes(pagination = {
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listmasternodes', [pagination, verbose], 'number');
        });
    }
    /**
     * Returns information about a single masternode
     *
     * @param {string} masternodeId The masternode's id.
     * @return {Promise<MasternodeResult>}
     */
    getMasternode(masternodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmasternode', [masternodeId], 'number');
        });
    }
    /**
     * Creates a transaction resigning a masternode.
     *
     * @param {string} masternodeId The masternode's id.
     * @param {UTXO[]} [utxos = []] Array of specified utxos to spend.
     * @param {string} [utxos.txid] The transaction id.
     * @param {number} [utxos.vout] The output number.
     * @return {Promise<string>} Resignation Transaction.
     */
    resignMasternode(masternodeId, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('resignmasternode', [masternodeId, utxos], 'number');
        });
    }
    /**
     * Set special governance variables
     *
     * @param {Record<string, any>} input json object
     * @return {Promise<string>} hash
     *
     */
    setGov(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setgov', [input], 'number');
        });
    }
    /**
     * Get information about governance variable
     *
     * @param {string} name governance name
     * @return {Promise<Record<string, any>} governance information as json object
     */
    getGov(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getgov', [name], 'bignumber');
        });
    }
    /**
     * Returns number of unique masternodes in the last specified number of blocks.
     *
     * @param {number} [blockCount=20160] The number of blocks to check for unique masternodes.
     * @return {Promise<number>} Number of unique masternodes seen
     */
    getActiveMasternodeCount(blockCount = 20160) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getactivemasternodecount', [blockCount], 'number');
        });
    }
}
exports.Masternode = Masternode;
//# sourceMappingURL=masternode.js.map